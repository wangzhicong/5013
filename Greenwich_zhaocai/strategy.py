import pandas as pd
import pickle
import numpy as np
from auxiliary import *
import numpy as np
import bigfloat as bg
from numpy.linalg import norm
import math
import sys
if not sys.warnoptions:
    import warnings
    warnings.simplefilter("ignore")

# Bayesian regression model learnt parameters
w_BTC = np.array([0.0, 1.515611669307353e-06, -3.0540922787140065e-05, 1.2362617671752183e-05])
w_BCH = np.array([0.0, 3.024386958586751e-05, 4.4473320989700415e-06, -1.1413577268887765e-05])
w_ETH = ([0.0, -1.561997757956787e-06, -2.0347123272206327e-06, -9.795150686504873e-07])
w_LTC = np.array([0.0, -1.561997757956787e-06, -2.0347123272206327e-06, -9.795150686504873e-07])
# asset_index_BTC
asset_index_BCH = 0
asset_index_BTC = 1
asset_index_ETH = 2
asset_index_LTC = 3
time_sieries_length = 720
time_interval = 1 # 1 minute
num = 0
s1_BTC = pd.read_csv('BTCs1_no_ask.csv').values
s2_BTC = pd.read_csv('BTCs2_no_ask.csv').values
s3_BTC = pd.read_csv('BTCs3_no_ask.csv').values

s1_BCH = pd.read_csv('BCHs1_no_ask.csv').values
s2_BCH = pd.read_csv('BCHs2_no_ask.csv').values
s3_BCH = pd.read_csv('BCHs3_no_ask.csv').values

s1_ETH = pd.read_csv('ETHs1_no_ask.csv').values
s2_ETH= pd.read_csv('ETHs2_no_ask.csv').values
s3_ETH = pd.read_csv('ETHs3_no_ask.csv').values

s1_LTC = pd.read_csv('LTCs1_no_ask.csv').values
s2_LTC = pd.read_csv('LTCs2_no_ask.csv').values
s3_LTC = pd.read_csv('LTCs3_no_ask.csv').values

def predict_dpi(x, s):
    """Predict the average price change Δp_i, 1 <= i <= 3.

    Args:
        x: A numpy array of floats representing previous prices.
        s: A 2-dimensional numpy array generated by choose_effective_centers().

    Returns:
        A big float representing average price change Δp_i.
    """
    num = 0
    den = 0
    for i in range(len(s)):
        y_i = s[i, len(x)]
        x_i = s[i, :len(x)]
        exp = bg.exp(-0.25 * norm(x - x_i) ** 2)
        num += y_i * exp
        den += exp
    return num / den

def predict_dps(prices, s1, s2, s3, w, t=0.001):
    """Predict average price changes (final estimations Δp) over the third
       time period.

    Args:
        prices: A numpy array of floats representing prices over the third time
            period.
        s1: A 2-dimensional numpy array generated by choose_effective_centers()
        s2: A 2-dimensional numpy array generated by choose_effective_centers().
        s3: A 2-dimensional numpy array generated by choose_effective_centers().
        w: A tuple (w0, w1, w2, w3) generated by model.

    Returns:
        A numpy array of floats. Each array element represents the final
        estimation Δp.
    """
    #dps = []
    w0, w1, w2, w3 = w
    ts1 = prices[-180:]
    ts2 = prices[-360:]
    ts3 = prices[0:720]
    dp1 = predict_dpi(ts1, s1)
    dp2 = predict_dpi(ts2, s2)
    dp3 = predict_dpi(ts3, s3)
    if(math.isnan(dp1)):
        dp1 = 0
    if(math.isnan(dp2)):
        dp2 = 0
    if(math.isnan(dp3)):
        dp3 = 0
    dp = w0 + w1 * dp1 + w2 * dp2 + w3 * dp3
    # print('dp', dp)
    position = 0
    if(dp > t):
        position = 1
    elif(dp < -t):
        position = -1
    else:
        position = 0
    return position, dp

# Here is your main strategy function
# Note:
# 1. DO NOT modify the function parameters (time, data, etc.)
# 2. The strategy function AWAYS returns two things - position and memory:
# 2.1 position is a np.array (length 4) indicating your desired position of four crypto currencies next minute
# 2.2 memory is a class containing the information you want to save currently for future use


def handle_bar(counter,  # a counter for number of minute bars that have already been tested
               time,  # current time in string format such as "2018-07-30 00:30:00"
               data,  # data for current minute bar (in format 2)
               init_cash,  # your initial cash, a constant
               transaction,  # transaction ratio, a constant
               cash_balance,  # your cash balance at current minute
               crypto_balance,  # your crpyto currency balance at current minute
               total_balance,  # your total balance at current minute
               position_current,  # your position for 4 crypto currencies at this minute
               memory  # a class, containing the information you saved so far
               ):

    # Pattern for long signal:
    # When the predicted signal is rising, we long 1 BTC at the next bar; otherwise we short 1 BTC at the next bar.

    # Pattern for short signal:
    # When the predicted probability of rising is low (i.e., lower than 0.45), we short 1 BTC at the next bar.

    # No controlling of the position is conducted in this strategy.

    output_index = 0
    position_new = position_current
    # only save close price with the setting time_interval
    if (counter == 0):
        memory.data_save = pd.DataFrame(columns = ['close_BTC', 'close_BCH', 'close_LTC', 'close_ETH' ])

    if ((counter + 1) >= time_sieries_length * time_interval) :
        memory.data_save.loc[int((counter + 1) / time_interval) - 1] = \
            data[asset_index_BTC,][0], data[asset_index_BCH,][0], data[asset_index_LTC,][0], data[asset_index_ETH,][0]

        bar_BTC = generate_series(memory.data_save['close_BTC'][-time_sieries_length:], time_sieries_length) # pandas dataframe
        # bar_BCH = generate_series(memory.data_save['close_BCH'][-time_sieries_length:], time_sieries_length) # pandas dataframe
        bar_LTC = generate_series(memory.data_save['close_LTC'][-time_sieries_length:], time_sieries_length) # pandas dataframe
        bar_ETH = generate_series(memory.data_save['close_ETH'][-time_sieries_length:], time_sieries_length) # pandas dataframe

        pred_vaule_BTC, dp_BTC= predict_dps((np.array(bar_BTC.tail(1)))[0], s1_BTC, s2_BTC, s3_BTC, w_BTC, t=0.000001)
        # BTC_csv.loc[output_index] = pred_vaule_BTC, dp_BTC
        # print('pred_vaule_BTC, dp_BTC', pred_vaule_BTC, dp_BTC)

        #pred_vaule_BCH, dp_BCH = predict_dps((np.array(bar_BCH.tail(1)))[0], s1_BCH, s2_BCH, s3_BCH, w_BCH, t=0.0001)
        #print('pred_vaule_BCH, dp_BCH', pred_vaule_BCH, dp_BCH)
        #BCH_csv.loc[output_index] = pred_vaule_BCH, dp_BCH

        pred_vaule_LTC, dp_LTC= predict_dps((np.array(bar_LTC.tail(1)))[0], s1_LTC, s2_LTC, s3_LTC, w_LTC, t=0.000001)
        #print('pred_vaule_LTC, dp_LTC', pred_vaule_LTC, dp_LTC)
        # LTC_csv.loc[output_index] = pred_vaule_LTC, dp_LTC


        pred_vaule_ETH, dp_ETH = predict_dps((np.array(bar_ETH.tail(1)))[0], s1_ETH, s2_ETH, s3_ETH, w_ETH, t=0.000001)
        # print('pred_vaule_ETH, dp_ETH', pred_vaule_ETH, dp_ETH)
        # ETH_csv.loc[output_index] = pred_vaule_ETH, dp_ETH

        # if(pred_vaule[0] != 0):
        #    print(pred_vaule[0], counter)
        output_index += 1
        position_new[asset_index_BTC] += pred_vaule_BTC
        #position_new[asset_index_BCH] += pred_vaule_BCH
        position_new[asset_index_LTC] += pred_vaule_LTC
        position_new[asset_index_ETH] += pred_vaule_ETH
    else:
        index = (counter + 1) % time_interval
        if(index == 0):
           memory.data_save.loc[int((counter + 1) / time_interval) - 1] = \
               data[asset_index_BTC,][0], 0, data[asset_index_LTC,][0], data[asset_index_ETH,][0]

    # End of strategy
    return position_new, memory
